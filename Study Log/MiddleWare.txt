MiddleWare : return 전에 실행되는 추가 함수들
-> 모든 기능을 한 함수에 밀어널을 이유도 없을 뿐만 아니라...
-> 프로그래밍의 기본 정신에 어긋남!
-> 그래서 여러 함수로 나눠서 실행하는 것

const uselessMiddleWare = (req, res, next) =>{
	console.log(`Someone want to go ${req.url}`);
	//return res.send("HaHa! Interupting!"); 도중에 return 해버리면 next는 실행이 안됨
	next();// next 함수 호출
}
-> 기본적으로 next라는 함수 객체를 받는다.

app.get("/", uselessMiddleWare, homeController);//root로 Request를 보내면 callback을 시켜주겠다.
-> 미들웨어들의 순서는 get에서는 저렇게 순서대로 적용된다.
-> 즉 이 코드에서는 uselessMiddleWare의 next는 homeController이다.

Summary:
1. Middlewares are software between request and response.
2. All middlewares are handlers. All controllers are middlewares.
3. They have three arguments including next argument. (req, res, next)
4. Next argument calls [next()] the next handler function if it exists.
For example, consider below code and comments:
```
// though it starts with middleware "one" it will eventually end up with a controller "three" because next() was called.
// You can put codes inside a body of middlewares "one" and "two" to check something before they get to the controller "three"
const one = (req,res,next) => {
next();
}
const two = (req,res,next) => {
next();
}
const three = (req,res) => {
console.log("Now three is handling")
}

// app.get will handle users who visit "/" URL with "one" handler
app.get("/", one, two, three)
```
I wish this helps. Good luck!

app.use(uselessMiddleWare);
-> use란 미들웨어 전용 함수 : 전역 미들웨어
-> get이나 post에 일일이 적용할 필요없이 use를 통해서 적용가능
-> 단 순서가 중요하기 때문에 get이 use 앞에 있을경우 해당 get에 대해서는 적용되지 않음

app.get(~~~);//1
app.use(logger);
app.use(protectingMiddleware);
app.get(~~~);//2
-> 즉 1은 미들웨어가 실행되지 않지만 2는 실행되며
-> logger가 먼저 실행되고 protectingMiddleware가 그 다음 실행됨

`app.use()`: allows you to create global middlewares
- Global middlewares: Middlewares that work in any URL
-- We can use a function in every route.
- If you put middleware at the top, that means the middleware is going to be used by all the other routes.

app.use(gossipMiddleware);
app.get("/", handleHome);
- The order is important
- Express executes everything in order like JS from top to bottom.

Every handler, every component has req, res, and next.
Every controller has a `next` if you need it.

const privateMiddleware = (req, res, next) => {
const url = req.url;
if (url === "/protected") {
return res.send("Not Allowed");
}
console.log("Allowed, you may continue.");
next();
}; // This is the middleware becoming a controller.

Middleware is just like a regular controller except that we get one more argument: `next`.
- If a middleware doesn't call `next()`, the next functions are never going to be executed.
- If a middleware returns something, it's going to stop the connection.
- Some middlewares call the `next` function and some use `res.send()`.

Any function here (`app.get("/", logger, handleHome);`) can be a middleware or controller.
- If a function calls `next`, that becomes a middleware.
- If another controller calls `res.send`, that's not a middleware b/c it kills the function.
- Middlewares are read from left to right.